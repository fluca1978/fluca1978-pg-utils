#+TITLE:     PostgreSQL 10
#+AUTHOR:    Luca Ferrari
#+EMAIL:     fluca1978@gmail.com
#+DATE:      <2017-08-25 ven>
#+LANGUAGE:  it

#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:

#+startup: beamer
#+LaTeX_CLASS: beamer
#+latex_header: \mode<beamer>{\usetheme{Madrid}}
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Outline}\tableofcontents[currentsection]\end{frame}}

#+BEAMER_HEADER: \subtitle{il database Open Source piu' avanzato del pianeta}
#+BEAMER_HEADER: \institute[ITPUG]{Italian PostgreSQL Users' Group (ITPUG)\\\url{http://www.itpug.org}}
#+BEAMER_HEADER: \institute[fluca1978]{fluca1978\\\url{https://fluca1978.github.io}}
#+BEAMER_HEADER: \titlegraphic{\includegraphics[height=3cm]{./images/logo.png}}


* Introduzione a PostgreSQL
** Cos'è?
   PostgreSQL è un *Object Relational Database Management System* (ORDBMS).

*** O-RDBMS                                                    :B_definition:
   *Object* non è da intendersi relativamente al paradigma /OOP/ quanto al fatto
   che un utente /puo' estendere il database con i propri "oggetti"/.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

Ad esempio, PostgreSQL non supporta i /query-hints/ tanto famosi in altri sistemi
commerciali: per gli sviluppatori questa funzionalità non ha senso e non è mai stata
(e mai verrà) implementata.

#+begin_quote
Approccio simile a quello di OpenBSD!
#+end_quote

   PostgreSQL è il naturale discendente di *Ingres* (dopo, /post/, gres), un database
   accademico/sperimentale inventato dal prof. Michael Stonebreaker e commercializzato
   indicativamente nello stesso spazio temporale di Oracle (1989 circa).

   Tutto inizia alla Berkely University of California.



** Quand'è?

   | Nome          | Anno di produzione | Note                             |
   |---------------+--------------------+----------------------------------|
   | POSTGRES      |               1989 | successore di Ingres             |
   | POSTGRES95    |               1994 | viene aggiunto un interprete SQL |
   | Postgres 1    |               1995 |                                  |
   | PostgreSQL 6  |               1997 |                                  |
   | PostgreSQL 7  |               2000 | foreign keys, join e no-crash    |
   | PostgreSQL 8  |               2005 | port Windows nativo              |
   | PostgreSQL 9  |               2010 | Replication                      |
   | PostgreSQL 10 |               2017 | ...                              |

   #+begin_quotation
The copyright of Postgres 1.0 has been loosened to be freely modifiable
and modifiable for any purpose.  Please read the COPYRIGHT file.
Thanks to Professor Michael Stonebraker for making this possible.
--- Release 1.0
#+end_quotation

** Di chi è?
   PostgreSQL non è guidato da nessun vendor e di conseguenza _non ha una
   lista di clienti da soddisfare_. Questo significa che
   una feature sarà implementata in PostgreSQL solo se ha senso dal punto di
   vista /tecnico/ e /scientifico/.

*** Approccio culturale :B_definition:
    PostgreSQL is a *non-commercial, all volunteer, free software project*,
    and as such *there is no formal list of feature requirements*
    required for development.
    We really do follow the mantra of
    letting developers scratch their own itches.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Ad esempio, PostgreSQL non supporta i /query-hints/ tanto famosi in altri sistemi
commerciali: per gli sviluppatori questa funzionalità non ha senso e non è mai stata
(e mai verrà) implementata.

#+begin_quote
Approccio simile a quello di OpenBSD!
#+end_quote

** Per chi è?
Licenza *BSD* (anche per il logo):


#+begin_src
PostgreSQL Database Management System
(formerly known as Postgres, then as Postgres95)

Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group

Portions Copyright (c) 1994, The Regents of the University of California

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement
is hereby granted, provided that the above copyright notice and this
paragraph and the following two paragraphs appear in all copies.
#+end_src


** Quanto costa?
   Il progetto è /Open Source/ ed è /Free/.

   Esistono diverse varianti commerciali che si differenziano dalla versione
   /mainstream/ per funzionalità (es. replica multi-master, query multi-nodo, ecc.)
   e per un /costo/ che dipende direttamente dal vendor.

   Molti degli sviluppatori della versione mainstream sono in realtà _anche_ sviluppatori
   di un qualche vendor.


** Qual'era?
   In PostgreSQL i numeri di versione */erano/* a tre cifre separati da punto:
   - */release brand/* (es. 7, no-crash, 8 MS Windows portability, 9 Replication)
   - */year release/*  (da quanti anni si ha questo brand)
   - */minor release/* (rilasciata circa ogni quattro mesi o in presenza di gravi
     problemi di sicurezza o consistenza)

*** Major version vs Minor Version :B_theorem:
    - *9.5*.1 # major version 9.5, minor version 1
      - 9.5.1 compatibile con 9.5.2, 9.5.3, ...
    - *9.6*.2 # major version 9.6, minor version 2
      - incompatibile con 9.5.x!

*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
   Le prime due cifre rappresentavano una *major version* e quindi erano segnale di
   possibile incompatibilità.


** Qual'é?
   Dalla versione 10 la numerazione è diventata a due sole cifre.

   La cifra prima del punto rappresenta la /major version/.

   *Questo rappresenta una incompatibilità semantica con il passato*: gli script
   che facevano affidamento alla versione devono modificare la propria logica!

   L'unico metodo affidabile è quello di considerare che ogni cifra viene
   usata con un formato ~printf(2)~ pari a ~%02d~ e che il numero
   dell'anno da ora in avanti è sempre zero.

   | Versione | Major | Minor | Internal |
   |----------+-------+-------+----------|
   |    9.5.1 |   9.5 |     1 |   090501 |
   |    9.6.4 |   9.6 |     4 |   090604 |
   |----------+-------+-------+----------|
   |     10.0 |    10 |     0 |   100000 |
   |     10.1 |    10 |     1 |   100001 |

** Quanto dura?
   Ogni /major release/ di PostgreSQL viene manutenuta per *5 anni* dalla data di primo rilascio.
   Una volta che una release raggiunge la *End Of Life* nessun pacchetto binario sarà piu' rilasciato
   ma potrebbe essere aggiornato (in retrocompatibilità) l'albero dei sorgenti (a discrezione degli
   sviluppatori e senza alcuna garanzia).

   Ecco un esempio delle prossime "scadenze":

| Version | First release date  | 	EOL date       |
|---------+---------------------+------------------|
|     9.6 | 	September 2016 	 | September 2021   |
|     9.5 | 	January 2016 	   | January 2021     |
|     9.4 | 	December 2014 	  | December 2019    |
|     9.3 | 	September 2013 	 | September 2018   |
|     9.2 | 	September 2012 	 | *September 2017* |

** Quanto è?
   E' difficile /spaventare/ una istanza PostgreSQL!

| Dato                        | Limite massimo                       |
|-----------------------------+--------------------------------------|
| Maximum Database Size	     | Unlimited                            |
| Maximum Table Size	        | 32 TB                                |
| Maximum Row Size	          | 1.6 TB                               |
| Maximum Field Size	        | 1 GB                                 |
| Maximum Rows per Table	    | Unlimited                            |
| Maximum Columns per Table	 | 250 - 1600 depending on column types |
| Maximum Indexes per Table	 | Unlimited                            |



** Chi lo usa?

   Alcuni esempi:

#+ATTR_LATEX: :width 0.2\textwidth
 [[./images/debian.png]]
 [[./images/redhat.png]]
[[./images/cisco.png]]
[[./images/skype.png]]


** Chi lo sviluppa?
   *Chiunque*, anche tu! Non esiste un /benevolent dictator/!

   Tre livelli principali di sviluppatori:
   1. *core team*: 5 membri storici che si occupano di gestire il ciclo di rilascio e tutte le questioni
      "spinose" (mancanza di consenso, disciplina, ecc)
      - Peter Eisentraut
      - Magnus Hagander
      - Tom Lane
      - Bruce Momjian
      - Dave Page
   2. *major contributors*: /sviluppatori fidati/ (commit access) che lavorano abitualmente alle funzionalità del
      progetto
   3. *contributor*: chiunque fornisca una patch, una proposta, una traduzione, ...


   - *hacker emeritus*: chi ha lavorato in passato al progetto con particolare successo
      (Josh Berkus, Marc G. Fournier, Thomas G. Lockhart, Vadim B. Mikheev, Jan Wieck)

** Come si sviluppa?
   Si utilizza ~git~ (migrato da CVS intorno al 2009).

   #+begin_src sh
% git clone git://git.postgresql.org/git/postgresql.git

Cloning into 'postgresql'...
...
% du -hs postgresql
356M    postgresql
% git rev-list --all --count
59672
   #+end_src

   - Linguaggio di programmazione principale: ~C~, stile BSD (~style(9)~).
   - Strumenti di sviluppo ben noti: ~gcc~, ~gmake~, ~autoconf~, ecc.
   - Strumenti (anche Perl) ad-hoc per mantenere il codice: ~pgindent~, ~git_changelog~,
     ~make_ctags~, ecc.


** Da quanto si sviluppa?
   Da molto tempo (oltre 30 anni), ma non si torna prima della versione 1.01 di *Postgres95*,
   ramo di sviluppo 6 del Postgres "attuale":

   #+begin_src sh
% git log `git rev-list --max-parents=0 HEAD`

commit d31084e9d1118b25fd16580d9d8c2924b5740dff
Author: Marc G. Fournier <scrappy@hub.org>
Date:   Tue Jul 9 06:22:35 1996 +0000

    Postgres95 1.01 Distribution - Virgin Sources
   #+end_src

* Concetti Generali
** Terminologia
- Ogni istanza di PostgreSQL gestisce un *cluster*.

- Un cluster è formato da uno o piu' *database*, ogni database può essere a sua volta
  scomposto in uno o piu' *schema* (/namespace logico/),
  che a sua volta può contenere uno o piu' *oggetti* (/tabelle, trigger, indici, funzioni/, ...).
  Ogni *database* è totalmente isolato dall'altro.

- Ogni oggetto può appartenere ad uno e un solo *tablespace* (/spazio fisico/).

- Il *cluster* mantiene anche le informazioni relative agli utenti e ai permessi.
  Gli utenti vengono chiamati *ruoli* e rappresentano sia singole utenze che gruppi
  (quindi un ruolo può contenere altri ruoli).

In linea con la filosofia Unix, PostgreSQL vuole svolgere un compito solo nel miglior modo possibile: gestire
i dati. E' compito del DBA documentarsi e aggiungere le estensioni necessarie a seconda del caso d'uso (es. pooling).


** Cluster di Database
Un singolo cluster quindi può gestire un albero di oggetti a granularità molto specifica:

  - /database 1/
    - /schema ~public~/ (default)
    - /schema 1/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
    - /schema 2/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
  - /database 2/
    - /schema ~public~/ (default)
    - /schema 1/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
    - /schema 2/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/

** Analogia tra Cluster e OS
L'isolamento e la gestione di un cluster ricorda molto quella di un sistema operativo:

| PostgreSQL                                | Unix                             |
|-------------------------------------------+----------------------------------|
| cluster                                   | OS                               |
| ruolo                                     | utente                           |
| tablespace                                | mount point                      |
|-------------------------------------------+----------------------------------|
| database                                  | home directory                   |
| schema                                    | sottodirectory  (es ~$HOME/bin~) |
| oggetto (tabella, trigger, funzione, ...) | file, script                     |


** Schema a Processi: Connessioni
PostgreSQL utilizza uno *schema a processi*: /ogni connessione viene gestita da un sottoprocesso creato ad-hoc/.


*** Processi vs Thread
Ci sono svariate ragioni per preferire uno schema a processi rispetto ad uno a thread: *isolamento* e *portabilità*
sono le principali.

*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Il processo principale è denominato *postmaster*; ogni volta che questo riceve una richiesta di connessione si effettua una /fork/
di un processo *postgres* (denominato anche *backend*) delegato a gestire la connessione.

*** Connessioni
    Una connessione può essere *TCP/IP* oppure su *socket locale*.
** Schema a Processi: IPC
   Siccome ogni processo è /fisicamente/ isolato, ma piu' connessioni possono dover condividere i dati, PostgreSQL
   utilizza un'area *shared memory* ove mantiene i dati. Tale zona di memoria è visibile a tutti i processi *postgres*.



   La shared memory viene organizzata in */pagine dati/* che rappresentano la copia in memoria dei dati persistenti su disco.
   Vi sono una serie di processi di utilità che si occupano di scaricare/caricare i dati dalla /shared memory/ e dal disco.
** File System
   PostgreSQL si appoggia al *filesystem* per lo stoccaggio dei dati in maniera persistenza.

   Questo offre diversi vantaggi, fra i quali la possibilità di un tuning molto raffinato
   circa le opzioni di funzionamento del filesystem (replica, journaling, ecc.).

   Dall'altra parte, il filesystem deve essere *affidabile*, pena il rischio di perdita dati.
* Installazione
** Tipologie di installazione
   E' possibile installare PostgreSQL:
   - mediante installer ufficiale
   - mediante pacchetti binari della propria installazione
   - compilando l'albero dei sorgenti

*** Macchina Virtuale                                          :B_definition:
   Tutte le prove qui mostrate sono state effettuate su una macchina virtuale con
   quattro dischi da 2GB utilizzati come spazio dati:
   #+begin_src sh
   $ uname -a
   FreeBSD olivia 11.1-RELEASE FreeBSD 11.1-RELEASE
   $ mount
   /dev/ada1p1 on /mnt/data1 (ufs, local, soft-updates)
   /dev/ada2p1 on /mnt/data2 (ufs, local, soft-updates)
   /dev/ada3p1 on /mnt/data3 (ufs, local, soft-updates)
   /dev/ada4p1 on /mnt/data4 (ufs, local, soft-updates)
   #+end_src
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** Installazione
Compilazione dai ports:
#+begin_src sh
# cd /usr/ports/databases/postgresql96-server
# make PREFIX=/opt/postgresql-9.6 BATCH=yes install clean
#+end_src

oppure il pacchetto binario:

#+begin_src sh
# pkg install postgresql96-server-9.6.5_1
#+end_src

In FreeBSD il database viene gestito dall'utente di sistema ~postgres~:

#+begin_src sh
# id postgres
uid=770(postgres) gid=770(postgres) groups=770(postgres)
#+end_src

altri sistemi operativi creano utenti simili (~psql~, ~pgsql~, ecc.).

** Avvio del servizio
I parametri di configurazione dipendono ovviamente dal sistema operativo, ad
esempio su FreeBSD le variabili di ~rc.conf~ sono visibili da
~/usr/local/etc/rc.d/postgresql~:

#+begin_src sh
#  postgresql_enable="YES"
#  postgresql_data="/var/db/postgres/data96"
#  postgresql_flags="-w -s -m fast"
#  postgresql_initdb_flags="--encoding=utf-8 --lc-collate=C"
#  postgresql_class="default"
#  postgresql_profiles=""
#+end_src

** PGDATA
PostgreSQL utilizza il filesystem del sistema operativo per salvare i dati in modo
persistente.

In particolare una directory specifica, denominata *PGDATA*, viene usata per contenere
tutti gli oggetti PostgreSQL. Tale directory deve essere inizializzata opportunamente
(creazione struttura directory, impostazione dei permessi, ecc.)
tramite il programma ~initdb~.

*** Importanza di PGDATA
   Un cluster può servire *una sola PGDATA* alla volta.
   La directory PGDATA deve essere protetta opportunamente da accessi involontari
   di altri utenti del sistema.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** initdb
Creazione di una directory per la memorizzazione del database (alcuni
sistemi operativi lo fanno automaticamente al momento dell'installazione
binaria):

#+begin_src sh
# mkdir /mnt/data1/pgdata
  && chown postgres:postgres /mnt/data1/pgdata
$ initdb --data-checksum --encoding="UTF-8"
         --pwprompt
         -D /mnt/data1/pgdata/
#+end_src

~initdb~ deve essere eseguito da un utente non privilegiato, le opzioni indicano:
- ~--data-checksum~: abilita il controllo sulle pagine dati del database;
- ~--encoding~: default encoding di ogni database se non sovrascritto;
- ~--pwprompt~: richiede la password del superutente di PostgreSQL (comodo per non impostarlo dopo);
- *~-D~*: l'opzione principale, indica *dove si troveranno i dati*.

** $PGDATA
La directory ~$PGDATA~ contiene diversi file e directory, in particolare:
- ~PG_VERSION~: file di testo con la versione che serve il cluster;
- *~postgresql.conf~*: configurazione principale del cluster;
- *~pg_hba.conf~*: file di accesso al database;
- *~base~*: directory sotto la quale si troveranno tutti i database;
- *~global~*: directory che contiene dati inter-database (es. cataloghi di sistema);
- ~pg_stat~ e ~pg_stat_tmp~: informazioni per le statistiche di sistema;
- *~pg_tblscp~*: link ai vari tablespace (oggetti fuori da ~base~);
- *~pg_xlog~* e ~pg_clog~: rispettivamente WAL e commit log.

Per altre informazioni vedere [[https://www.postgresql.org/docs/9.6/static/storage-file-layout.html][Storage File System Layout]].

** Connessione al servizio
Il file ~pg_hba.conf~ contiene le informazioni su quali metodi di autenticazione,
quali utenti, quali host remoti e quali database sono accessibili per la connessione.
Si può editare questo file prima di avviare il servizio (se si è impostata una password
per ~postgres~ superuser) o anche in seguito.

#+begin_src sh
# tipo  database   utente   da dove       metodo
local   all        all                    trust
host    all        all      127.0.0.1/32    md5
#+end_src

*** pg_hba.conf vs sudoers
    Il file ~pg_hba.conf~ è simile al file ~sudoers~, e come tale
    va gestito scrupolosamente.
    La parola ~all~ indica tutti gli utenti/database (a seconda di dove è messa).
    *Il metodo ~trust~ non richiede autenticazione e non va usato!*
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:



** Avvio del servizio
Una volta che i primi pezzi sono al loro posto, è possibile avviare il servizio:

#+begin_src sh
# service postgresql start
#+end_src

e se tutto va a buon fine...
#+begin_src sh
# psql -h localhost -U postgres -l
Password for user postgres:
   Name    |  Owner   | Encoding |
-----------+----------+----------+
 postgres  | postgres | UTF8     |
 template0 | postgres | UTF8     |
 template1 | postgres | UTF8     |
(3 rows)
#+end_src


** Database template
Quando viene inizializzata ~PGDATA~ il sistema crea due database chaimati /template/:
- ~template0~: la copia principale del template;
- *~template1~*: la copia usata in default.

Ogni votla che viene creato un nuovo database *le impostazioni di base sono copiate da ~template1~*
(che funge da /skel/ directory).

E' facoltà del DBA impostare ~template1~ opportunamente per far si che la creazione di nuovi database
abbia una base comune riconosciuta (es. schemi, linguaggi, ecc.).

~template0~ è la copia di sicurezza del template, qualora si "sporchi" troppo ~template1~.

** Database templating
I due database template non svolgono alcuna funzione particolare se non quella di essere
usati come possibili punti di origine di un nuovo database. In default, se non specificato, PostgreSQL
copia ~template1~, mentre ~template0~ dovrebbe essere lasciato /vergine/ per operazioni particolari
quali restore (può servire un database vuoto a cui collegarsi).

*** Creare i propri template
    E' possibile creare quanti database template si vuole e istruire il comando
    ~CREATE DATABASE~ per usare altri template oltre ~template1~. Si noti però
    che un database template non accetta connessioni durante la creazione, quindi
    questo *non è un meccanismo di /clonazione/ dei database!*
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** psql
Il pacchetto /client/ contiene un interprete da riga di comando, denominato ~psql~
che consente di collegarsi al database e svolgere /tutti/ i compiti necessari.

#+begin_src sh
% psql -h localhost -U postgres template1
Password for user postgres:
psql (9.6.5)
Type "help" for help.

template1=#
template1=# \q
%
#+end_src

I parametri di linea comando sono:
- ~-h~: host a cui collegarsi (hostname, indirizzo ip);
- ~-U~: utente con cui collegarsi (/ruolo/ PostgreSQL);
- database a cui collegarsi (es. ~template1~).

** psql: connection URI
Oltre a specificare ogni singolo parametro della conessione tramite opzioni di comando,
~psql~ consente di utilizzare un URI per la connessione, ad esempio:

#+begin_src sh
% psql postgresql://postgres@localhost:5432/template1
Password:
psql (9.6.5)
Type "help" for help.

template1=#
#+end_src

Parametri ulteriori possono essere specificati nell'URL (dopo ~?~),
come ad esempio:

#+begin_src sh
postgresql://postgres@localhost/template1?sslmode=require
#+end_src

** psql: prompt

In modo simile alla shell, il prompt di ~psql~ mostra:
- il database al quale si è collegati (~template1~);
- un ~#~ se si è superuser o ~>~ se si è utenti normali.

Si esce da ~psql~ con ~\q~.

** Quale versione del server?
~psql~ mostra all'avvio la propria versione (client) ma con una query
è possibile capire anche la versione del server:

#+begin_src SQL
template1=# SELECT version();
 PostgreSQL 9.6.5 on amd64-portbld-freebsd11.0, ...
(1 row)
#+end_src


La funzione speciale ~version()~ viene compilata al momento
del build del pacchetto binario.



** psql, ruoli, database
In default ~psql~ cerca di collegarsi a un database che ha lo stesso nome
utente dell'utente che esegue il comando stesso, con un ruolo che ha
lo stesso nome.
In altre parole:

#+begin_src sh
% id -p
uid     luca

% psql
psql: FATAL:  role "luca" does not exist
#+end_src

corrisponde a:

#+begin_src sh
% psql -h localhost -U luca luca
#+end_src

** psql: ruoli, database e variabili di ambiente
 In realtà quando non viene specificato un utente e/o un database
 ~psql~ cerca di collegarsi a quanto stabilito dalle variabili
 di ambiente ~PGUSER~ e ~PGDATABASE~ (e le relative ~PGHOST~ e ~PGPORT~):

#+begin_src sh
% export PGUSER=foo PGDATABASE=myDB
% psql
psql: FATAL:  no pg_hba.conf entry for host "[local]",
              user "foo",
              database "myDB", SSL off
#+end_src

** psql: aiuto
All'interno di ~psql~ ci sono due tipologie di aiuto:
- /aiuto sui comandi SQL/: si ottiene con ~\h~
  - ~\h~ senza argomenti mostra tutti i comandi SQL disponibili;
  - ~\h COMANDO~ mostra l'aiuto del comando SQL specificato;
- /aiuto su ~psql~/: si ottiene con ~\?~ e mostra tutti i comandi
  speciali di ~psql~. Tutti i comandi ~psql~ iniziano con backslash
  (es. ~\d~).


** psql: evitare la password
~psql~ consente di impostare un file di credenziali (~$HOME/.pgpass~) per collegarsi
a uno specifico database/host con uno specifico utente senza dover digitare
una password.
Ogni riga nel file contiene:
- host e porta a cui collegarsi;
- database a cui collegarsi (~*~ per tutti);
- username e password con cui collegarsi.

Il file non deve essere leggibile da altri utenti (es. permessi ~600~).

#+begin_src sh
% cat ~/.pgpass
127.0.0.1:5432:template1:postgres:xxxxxxxx

% psql -U postgres template1
template1=#
#+end_src

*** Errori comuni
    *Il file deve avere permessi ~rw~ per il solo proprietario*. Inoltre si deve specificare
    la porta a cui collegarsi dopo l'hostname!
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:



** psql: configurazione utente
~psql~ consente di specificare delle configurazioni utente nel file ~$HOME/.psqlrc~.
Tutti i comandi (~psql~ compatibili) specificati in tale file vengono eseguiti
prima di fornire il prompt all'utente.

Utile per impostare variabili, prompt, formati di output, ecc.
** psql: ~/.psqlrc
#+begin_src sh
\set HISTFILE ~/.psql_history_ :DBNAME
\set ON_ERROR_ROLLBACK on
\set ON_ERROR_STOP     on
\x
\set PROMPT1 '[%n @ %/ on %m] %l %x %# '
#+end_src

Il prompt corrisponde a: /username/ (~%n~), /database/ (~%/~),
/hostname/ (~%m~), /linea/ (~%l~), /stato transazione/ (~%x~)
e /prompt superutente o utente normale/ (~%#~).

** oid2name
 L'utility ~oid2name~ (modulo /contrib/) consente di esplorare velocamente
 la struttura dati su disco.
#+begin_src sh
% oid2name -H localhost -U postgres
Password:
All databases:
    Oid  Database Name  Tablespace
----------------------------------
  12758       postgres  pg_default
  12757      template0  pg_default
      1      template1  pg_default
#+end_src

Gli /oid/ visualizzati in questo caso corrispondono al nome *fisico su disco*
dei database:

#+begin_src sh
% sudo ls /mnt/data1/pgdata/base
1       12757   12758
#+end_src

** oid2name (2)
 Esploriamo il database ~template1~ su disco e cerchiamo di capire
 cosa contiene:

#+begin_src sh
% sudo stat /mnt/data1/pgdata/base/1/12618
107 65870 -rw------- 1 postgres postgres 145910 8192
#+end_src

A cosa corrisponde l'oggetto file ~12618~?

#+begin_src sh
% oid2name -H localhost -U postgres -d template1 -o 12618
Password:
From database "template1":
  Filenode  Table Name
----------------------
     12618  sql_sizing
#+end_src

*ATTENZIONE: si deve specificare a quale database si fa riferimento, poiché
gli stessi oid possono essere riciclati in database differenti*

** oid2name (3)
 E se si vuole trovare una tabella dato il suo nome?

 #+begin_src sh
% oid2name -H localhost -U postgres -d template1 -t sql_sizing
Password:
From database "template1":
  Filenode  Table Name
----------------------
     12618  sql_sizing
 #+end_src

~oid2name~ va ad interrogare il catalogo di sistema per trovare le informazioni
necessarie.
** Ruoli e Utenti
   Dalla versione 8.1 in poi PostgreSQL non distingue piu' fra utenti e gruppi
   ma usa il concetto di *ruolo* che rappresenta entrambi:
   - un ruolo può rappresentare un utente;
   - ad un ruolo si possono aggiungere altri utenti (e quindi rappresenta un gruppo).

*** Ruoli e Connessioni
    *Per collegarsi ad un database occorre sempre un ruolo*, ossia un utente
    PostgreSQL (che è logicamente separato da quello del sistema operativo).
    Quando viene inizializzato un cluster viene creato un ruolo superutente
    per permetterne la gestione (negli esempi ~postgres~).
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** Vedere i ruoli
Il catalogo ~pg_roles~ contiene le informazioni sui ruoli e le loro proprietà:

#+begin_src sql
# SELECT rolname, rolsuper, rolcreatedb, rolcanlogin
FROM pg_roles;
      rolname      | rolsuper | rolcreatedb | rolcanlogin
-------------------+----------+-------------+-------------
 pg_signal_backend | f        | f           | f
 postgres          | t        | t           | t
#+end_src

E' possibile creare utenti/gruppi/ruoli con privilegi di super utente, possibilità di creare nuovi
database e di collegarsi o no al cluster.

** Creare i ruoli
   Il comand SQL ~CREATE ROLE~ (o da terminale ~createuser~) consente di creare un nuovo utente/gruppo.
   Ad esempio si supponga di voler gestire un database di una applicazione definendo due utenti: uno applicativo
   e uno amministrativo/interattivo:

   #+begin_src sql
# CREATE ROLE my_app
  WITH NOLOGIN
  CONNECTION LIMIT 1
  PASSWORD 'xxx';
CREATE ROLE

# ALTER ROLE my_app WITH LOGIN;

# CREATE ROLE luca
  WITH CREATEDB LOGIN PASSWORD 'xxxxx'
  IN ROLE my_app;
CREATE ROLE
   #+end_src

Ora il ruolo ~my_app~ funge sia da utente che da gruppo a cui ~luca~ appartiene.
Si noti l'uso di ~ALTER ROLE~ per correggere un errore.

** Creare i ruoli (2)
   I ruoli appena creati risultano ora:
#+begin_src sql
# SELECT rolname, rolsuper, rolcreatedb, rolcanlogin, rolconnlimit
  FROM pg_roles;
      rolname      | rolsuper | rolcreatedb | rolcanlogin | rolconnlimit
-------------------+----------+-------------+-------------+--------------
 pg_signal_backend | f        | f           | f           |           -1
 postgres          | t        | t           | t           |           -1
 my_app            | f        | f           | t           |            1
 luca              | f        | t           | t           |           -1
#+end_src

** Creare i ruoli (3)
   E' ora possibile configurare il file ~.pgpass~ per i nuovi ruoli:
#+begin_src sh
% cat ~/.pgpass
127.0.0.1:5432_template1:postgres:postgres
localhost:5432:template1:luca:xxxxxx
localhost:5432:template1:my_app:xxxxx
#+end_src

*** Evitare di censire ogni singolo database
    Si ricordi che è possibile usare ~*~ per host, porta e database. Questo semplifica
    il deployment di nuovi database, ma dall'altro lato rende piu' complesso censire
    e controllare i database a cui si accede.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
** Creare un database
   Usando il comando SQL ~CREATE DATABASE~ è possibile aggiungere un nuovo database
   (e /opzionalmente/ aggiungere un commento per indicare lo scopo del database):
#+begin_src sql
# CREATE DATABASE testdb
  WITH OWNER 'luca';

# COMMENT ON DATABASE testdb IS 'A test database';
#+end_src

  Alternativamente si può usare il comando shell ~createdb~:
#+begin_src sh
% createdb --owner='luca' -e -h localhost -U postgres testdb 'A test database'
CREATE DATABASE testdb OWNER luca;
COMMENT ON DATABASE testdb IS 'A test database';
#+end_src

** Vedere i database disponibili
 Il catalogo ~pg_database~ contiene le informazioni circa i database presenti nel
 sistema:

#+begin_src sql
# SELECT datname FROM pg_database;
  datname
-----------
 postgres
 testdb
 template1
 template0
#+end_src

 Alternativamente si può usare l'opzione ~-l~ in ~psql~:
#+begin_src sh
% psql -h localhost -U postgres -l
...
Name              | testdb
Owner             | luca
Encoding          | UTF8
Collate           | C
Ctype             | C
Access privileges |
#+end_src
** Eliminare un database
 Avendo i privilegi corretti, si può usare il comando SQL ~DROP DATABASE~
 o il comando shell ~dropdb~:

#+begin_src sql
% psql -h localhost -U postgres template1
# DROP DATABASE testdb;
DROP DATABASE
#+end_src

#+begin_src sh
% dropdb -h localhost -U postgres testdb
#+end_src
