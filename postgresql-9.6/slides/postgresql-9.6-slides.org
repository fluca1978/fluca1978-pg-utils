#+TITLE:     PostgreSQL 10
#+AUTHOR:    Luca Ferrari
#+EMAIL:     fluca1978@gmail.com
#+DATE:      <2017-08-25 ven>
#+LANGUAGE:  it

#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:

#+startup: beamer
#+LaTeX_CLASS: beamer
#+latex_header: \mode<beamer>{\usetheme{Madrid}}
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Outline}\tableofcontents[currentsection]\end{frame}}

#+BEAMER_HEADER: \subtitle{il database Open Source piu' avanzato del pianeta}
#+BEAMER_HEADER: \institute[ITPUG]{Italian PostgreSQL Users' Group (ITPUG)\\\url{http://www.itpug.org}}
#+BEAMER_HEADER: \institute[fluca1978]{fluca1978\\\url{https://fluca1978.github.io}}
#+BEAMER_HEADER: \titlegraphic{\includegraphics[height=3cm]{./images/logo.png}}


* Introduzione a PostgreSQL
** Cos'è?
   PostgreSQL è un *Object Relational Database Management System* (ORDBMS).

*** O-RDBMS                                                    :B_definition:
   *Object* non è da intendersi relativamente al paradigma /OOP/ quanto al fatto
   che un utente /puo' estendere il database con i propri "oggetti"/.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

Ad esempio, PostgreSQL non supporta i /query-hints/ tanto famosi in altri sistemi
commerciali: per gli sviluppatori questa funzionalità non ha senso e non è mai stata
(e mai verrà) implementata.

#+begin_quote
Approccio simile a quello di OpenBSD!
#+end_quote

   PostgreSQL è il naturale discendente di *Ingres* (dopo, /post/, gres), un database
   accademico/sperimentale inventato dal prof. Michael Stonebreaker e commercializzato
   indicativamente nello stesso spazio temporale di Oracle (1989 circa).

   Tutto inizia alla Berkely University of California.



** Quand'è?

   | Nome          | Anno di produzione | Note                             |
   |---------------+--------------------+----------------------------------|
   | POSTGRES      |               1989 | successore di Ingres             |
   | POSTGRES95    |               1994 | viene aggiunto un interprete SQL |
   | Postgres 1    |               1995 |                                  |
   | PostgreSQL 6  |               1997 |                                  |
   | PostgreSQL 7  |               2000 | foreign keys, join e no-crash    |
   | PostgreSQL 8  |               2005 | port Windows nativo              |
   | PostgreSQL 9  |               2010 | Replication                      |
   | PostgreSQL 10 |               2017 | ...                              |

   #+begin_quotation
The copyright of Postgres 1.0 has been loosened to be freely modifiable
and modifiable for any purpose.  Please read the COPYRIGHT file.
Thanks to Professor Michael Stonebraker for making this possible.
--- Release 1.0
#+end_quotation

** Di chi è?
   PostgreSQL non è guidato da nessun vendor e di conseguenza _non ha una
   lista di clienti da soddisfare_. Questo significa che
   una feature sarà implementata in PostgreSQL solo se ha senso dal punto di
   vista /tecnico/ e /scientifico/.

*** Approccio culturale :B_definition:
    PostgreSQL is a *non-commercial, all volunteer, free software project*,
    and as such *there is no formal list of feature requirements*
    required for development.
    We really do follow the mantra of
    letting developers scratch their own itches.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Ad esempio, PostgreSQL non supporta i /query-hints/ tanto famosi in altri sistemi
commerciali: per gli sviluppatori questa funzionalità non ha senso e non è mai stata
(e mai verrà) implementata.

#+begin_quote
Approccio simile a quello di OpenBSD!
#+end_quote

** Per chi è?
Licenza *BSD* (anche per il logo):


#+begin_src
PostgreSQL Database Management System
(formerly known as Postgres, then as Postgres95)

Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group

Portions Copyright (c) 1994, The Regents of the University of California

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement
is hereby granted, provided that the above copyright notice and this
paragraph and the following two paragraphs appear in all copies.
#+end_src


** Quanto costa?
   Il progetto è /Open Source/ ed è /Free/.

   Esistono diverse varianti commerciali che si differenziano dalla versione
   /mainstream/ per funzionalità (es. replica multi-master, query multi-nodo, ecc.)
   e per un /costo/ che dipende direttamente dal vendor.

   Molti degli sviluppatori della versione mainstream sono in realtà _anche_ sviluppatori
   di un qualche vendor.


** Qual'era?
   In PostgreSQL i numeri di versione */erano/* a tre cifre separati da punto:
   - */release brand/* (es. 7, no-crash, 8 MS Windows portability, 9 Replication)
   - */year release/*  (da quanti anni si ha questo brand)
   - */minor release/* (rilasciata circa ogni quattro mesi o in presenza di gravi
     problemi di sicurezza o consistenza)

*** Major version vs Minor Version :B_theorem:
    - *9.5*.1 # major version 9.5, minor version 1
      - 9.5.1 compatibile con 9.5.2, 9.5.3, ...
    - *9.6*.2 # major version 9.6, minor version 2
      - incompatibile con 9.5.x!

*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
   Le prime due cifre rappresentavano una *major version* e quindi erano segnale di
   possibile incompatibilità.


** Qual'é?
   Dalla versione 10 la numerazione è diventata a due sole cifre.

   La cifra prima del punto rappresenta la /major version/.

   *Questo rappresenta una incompatibilità semantica con il passato*: gli script
   che facevano affidamento alla versione devono modificare la propria logica!

   L'unico metodo affidabile è quello di considerare che ogni cifra viene
   usata con un formato ~printf(2)~ pari a ~%02d~ e che il numero
   dell'anno da ora in avanti è sempre zero.

   | Versione | Major | Minor | Internal |
   |----------+-------+-------+----------|
   |    9.5.1 |   9.5 |     1 |   090501 |
   |    9.6.4 |   9.6 |     4 |   090604 |
   |----------+-------+-------+----------|
   |     10.0 |    10 |     0 |   100000 |
   |     10.1 |    10 |     1 |   100001 |

** Quanto dura?
   Ogni /major release/ di PostgreSQL viene manutenuta per *5 anni* dalla data di primo rilascio.
   Una volta che una release raggiunge la *End Of Life* nessun pacchetto binario sarà piu' rilasciato
   ma potrebbe essere aggiornato (in retrocompatibilità) l'albero dei sorgenti (a discrezione degli
   sviluppatori e senza alcuna garanzia).

   Ecco un esempio delle prossime "scadenze":

| Version | First release date  | 	EOL date       |
|---------+---------------------+------------------|
|     9.6 | 	September 2016 	 | September 2021   |
|     9.5 | 	January 2016 	   | January 2021     |
|     9.4 | 	December 2014 	  | December 2019    |
|     9.3 | 	September 2013 	 | September 2018   |
|     9.2 | 	September 2012 	 | *September 2017* |

** Quanto è?
   E' difficile /spaventare/ una istanza PostgreSQL!

| Dato                        | Limite massimo                       |
|-----------------------------+--------------------------------------|
| Maximum Database Size	     | Unlimited                            |
| Maximum Table Size	        | 32 TB                                |
| Maximum Row Size	          | 1.6 TB                               |
| Maximum Field Size	        | 1 GB                                 |
| Maximum Rows per Table	    | Unlimited                            |
| Maximum Columns per Table	 | 250 - 1600 depending on column types |
| Maximum Indexes per Table	 | Unlimited                            |



** Chi lo usa?

   Alcuni esempi:

#+ATTR_LATEX: :width 0.2\textwidth
 [[./images/debian.png]]
 [[./images/redhat.png]]
[[./images/cisco.png]]
[[./images/skype.png]]


** Chi lo sviluppa?
   *Chiunque*, anche tu! Non esiste un /benevolent dictator/!

   Tre livelli principali di sviluppatori:
   1. *core team*: 5 membri storici che si occupano di gestire il ciclo di rilascio e tutte le questioni
      "spinose" (mancanza di consenso, disciplina, ecc)
      - Peter Eisentraut
      - Magnus Hagander
      - Tom Lane
      - Bruce Momjian
      - Dave Page
   2. *major contributors*: /sviluppatori fidati/ (commit access) che lavorano abitualmente alle funzionalità del
      progetto
   3. *contributor*: chiunque fornisca una patch, una proposta, una traduzione, ...


   - *hacker emeritus*: chi ha lavorato in passato al progetto con particolare successo
      (Josh Berkus, Marc G. Fournier, Thomas G. Lockhart, Vadim B. Mikheev, Jan Wieck)

** Come si sviluppa?
   Si utilizza ~git~ (migrato da CVS intorno al 2009).

   #+begin_src sh
% git clone git://git.postgresql.org/git/postgresql.git

Cloning into 'postgresql'...
...
% du -hs postgresql
356M    postgresql
% git rev-list --all --count
59672
   #+end_src

   - Linguaggio di programmazione principale: ~C~, stile BSD (~style(9)~).
   - Strumenti di sviluppo ben noti: ~gcc~, ~gmake~, ~autoconf~, ecc.
   - Strumenti (anche Perl) ad-hoc per mantenere il codice: ~pgindent~, ~git_changelog~,
     ~make_ctags~, ecc.


** Da quanto si sviluppa?
   Da molto tempo (oltre 30 anni), ma non si torna prima della versione 1.01 di *Postgres95*,
   ramo di sviluppo 6 del Postgres "attuale":

   #+begin_src sh
% git log `git rev-list --max-parents=0 HEAD`

commit d31084e9d1118b25fd16580d9d8c2924b5740dff
Author: Marc G. Fournier <scrappy@hub.org>
Date:   Tue Jul 9 06:22:35 1996 +0000

    Postgres95 1.01 Distribution - Virgin Sources
   #+end_src

* Concetti Generali
** Terminologia
- Ogni istanza di PostgreSQL gestisce un *cluster*.

- Un cluster è formato da uno o piu' *database*, ogni database può essere a sua volta
  scomposto in uno o piu' *schema* (/namespace logico/),
  che a sua volta può contenere uno o piu' *oggetti* (/tabelle, trigger, indici, funzioni/, ...).
  Ogni *database* è totalmente isolato dall'altro.

- Ogni oggetto può appartenere ad uno e un solo *tablespace* (/spazio fisico/).

- Il *cluster* mantiene anche le informazioni relative agli utenti e ai permessi.
  Gli utenti vengono chiamati *ruoli* e rappresentano sia singole utenze che gruppi
  (quindi un ruolo può contenere altri ruoli).

In linea con la filosofia Unix, PostgreSQL vuole svolgere un compito solo nel miglior modo possibile: gestire
i dati. E' compito del DBA documentarsi e aggiungere le estensioni necessarie a seconda del caso d'uso (es. pooling).


** Cluster di Database
Un singolo cluster quindi può gestire un albero di oggetti a granularità molto specifica:

  - /database 1/
    - /schema ~public~/ (default)
    - /schema 1/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
    - /schema 2/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
  - /database 2/
    - /schema ~public~/ (default)
    - /schema 1/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/
    - /schema 2/
      - /tabelle, trigger, indici/ -> /tablespace disco SSD/
      - /tabelle, trigger, indici/ -> /tablespace disco lento/

** Analogia tra Cluster e OS
L'isolamento e la gestione di un cluster ricorda molto quella di un sistema operativo:

| PostgreSQL                                | Unix                             |
|-------------------------------------------+----------------------------------|
| cluster                                   | OS                               |
| ruolo                                     | utente                           |
| tablespace                                | mount point                      |
|-------------------------------------------+----------------------------------|
| database                                  | home directory                   |
| schema                                    | sottodirectory  (es ~$HOME/bin~) |
| oggetto (tabella, trigger, funzione, ...) | file, script                     |


** Schema a Processi: Connessioni
PostgreSQL utilizza uno *schema a processi*: /ogni connessione viene gestita da un sottoprocesso creato ad-hoc/.


*** Processi vs Thread
Ci sono svariate ragioni per preferire uno schema a processi rispetto ad uno a thread: *isolamento* e *portabilità*
sono le principali.

*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Il processo principale è denominato *postmaster*; ogni volta che questo riceve una richiesta di connessione si effettua una /fork/
di un processo *postgres* (denominato anche *backend*) delegato a gestire la connessione.

*** Connessioni
    Una connessione può essere *TCP/IP* oppure su *socket locale*.
** Schema a Processi: IPC
   Siccome ogni processo è /fisicamente/ isolato, ma piu' connessioni possono dover condividere i dati, PostgreSQL
   utilizza un'area *shared memory* ove mantiene i dati. Tale zona di memoria è visibile a tutti i processi *postgres*.



   La shared memory viene organizzata in */pagine dati/* che rappresentano la copia in memoria dei dati persistenti su disco.
   Vi sono una serie di processi di utilità che si occupano di scaricare/caricare i dati dalla /shared memory/ e dal disco.
** File System
   PostgreSQL si appoggia al *filesystem* per lo stoccaggio dei dati in maniera persistenza.

   Questo offre diversi vantaggi, fra i quali la possibilità di un tuning molto raffinato
   circa le opzioni di funzionamento del filesystem (replica, journaling, ecc.).

   Dall'altra parte, il filesystem deve essere *affidabile*, pena il rischio di perdita dati.
* Installazione
** Tipologie di installazione
   E' possibile installare PostgreSQL:
   - mediante installer ufficiale
   - mediante pacchetti binari della propria installazione
   - compilando l'albero dei sorgenti

*** Macchina Virtuale                                          :B_definition:
   Tutte le prove qui mostrate sono state effettuate su una macchina virtuale con
   quattro dischi da 2GB utilizzati come spazio dati:
   #+begin_src sh
   $ uname -a
   FreeBSD olivia 11.1-RELEASE FreeBSD 11.1-RELEASE
   $ mount
   /dev/ada1p1 on /mnt/data1 (ufs, local, soft-updates)
   /dev/ada2p1 on /mnt/data2 (ufs, local, soft-updates)
   /dev/ada3p1 on /mnt/data3 (ufs, local, soft-updates)
   /dev/ada4p1 on /mnt/data4 (ufs, local, soft-updates)
   #+end_src
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** Installazione
Compilazione dai ports:
#+begin_src sh
# cd /usr/ports/databases/postgresql96-server
# make PREFIX=/opt/postgresql-9.6 BATCH=yes install clean
#+end_src

oppure il pacchetto binario:

#+begin_src sh
# pkg install postgresql96-server-9.6.5_1
#+end_src

In FreeBSD il database viene gestito dall'utente di sistema ~postgres~:

#+begin_src sh
# id postgres
uid=770(postgres) gid=770(postgres) groups=770(postgres)
#+end_src

altri sistemi operativi creano utenti simili (~psql~, ~pgsql~, ecc.).

** Avvio del servizio
I parametri di configurazione dipendono ovviamente dal sistema operativo, ad
esempio su FreeBSD le variabili di ~rc.conf~ sono visibili da
~/usr/local/etc/rc.d/postgresql~:

#+begin_src sh
#  postgresql_enable="YES"
#  postgresql_data="/var/db/postgres/data96"
#  postgresql_flags="-w -s -m fast"
#  postgresql_initdb_flags="--encoding=utf-8 --lc-collate=C"
#  postgresql_class="default"
#  postgresql_profiles=""
#+end_src

** PGDATA
PostgreSQL utilizza il filesystem del sistema operativo per salvare i dati in modo
persistente.

In particolare una directory specifica, denominata *PGDATA*, viene usata per contenere
tutti gli oggetti PostgreSQL. Tale directory deve essere inizializzata opportunamente
(creazione struttura directory, impostazione dei permessi, ecc.)
tramite il programma ~initdb~.

*** Importanza di PGDATA
   Un cluster può servire *una sola PGDATA* alla volta.
   La directory PGDATA deve essere protetta opportunamente da accessi involontari
   di altri utenti del sistema.
*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** initdb
Creazione di una directory per la memorizzazione del database (alcuni
sistemi operativi lo fanno automaticamente al momento dell'installazione
binaria):

#+begin_src sh
# mkdir /mnt/data1/pgdata
  && chown postgres:postgres /mnt/data1/pgdata
$ initdb --data-checksum --encoding="UTF-8"
         --pwprompt
         -D /mnt/data1/pgdata/
#+end_src

~initdb~ deve essere eseguito da un utente non privilegiato, le opzioni indicano:
- ~--data-checksum~: abilita il controllo sulle pagine dati del database;
- ~--encoding~: default encoding di ogni database se non sovrascritto;
- ~--pwprompt~: richiede la password del superutente di PostgreSQL (comodo per non impostarlo dopo);
- *~-D~*: l'opzione principale, indica *dove si troveranno i dati*.

** $PGDATA
La directory ~$PGDATA~ contiene diversi file e directory, in particolare:
- ~PG_VERSION~: file di testo con la versione che serve il cluster;
- *~postgresql.conf~*: configurazione principale del cluster;
- *~pg_hba.conf~*: file di accesso al database;
- *~base~*: directory sotto la quale si troveranno tutti i database;
- *~global~*: directory che contiene dati inter-database (es. cataloghi di sistema);
- ~pg_stat~ e ~pg_stat_tmp~: informazioni per le statistiche di sistema;
- *~pg_tblscp~*: link ai vari tablespace (oggetti fuori da ~base~);
- *~pg_xlog~* e ~pg_clog~: rispettivamente WAL e commit log.

Per altre informazioni vedere [[https://www.postgresql.org/docs/9.6/static/storage-file-layout.html][Storage File System Layout]].
